#!/usr/bin/env python3

import argparse
import copy
import configparser
import datetime
import enum
import os
import sys

import bash_imitation
import exp_lib
import lib


FPATH = os.path.dirname(os.path.realpath(__file__))
LT_EXECUTABLE = os.path.join(FPATH, "lt_driver.py")
DRIVER_EXECUTABLE = os.path.join(FPATH, "driver.py")


class Stage(enum.Enum):

	""" Represents the stages of the pipeline."""

	CREATE_NEW_DIRS = "create_new_dirs"
	METADATA = "metadata"
	LATENCY_THROUGHPUT = "latency_throughput"
	DRIVER = "driver"

	def __str__(self):
		return self.value

	@staticmethod
	def next(stage):
		if stage == Stage.CREATE_NEW_DIRS:
			return Stage.METADATA
		elif stage == Stage.METADATA:
			return Stage.LATENCY_THROUGHPUT
		elif stage == Stage.LATENCY_THROUGHPUT:
			return Stage.DRIVER


def extract_human_tag(config_file):

	""" Reads the human tag from the config file.

	Args:
		config_file (str): .ini file
	
	Returns:
		human tag
	"""

	config = configparser.ConfigParser()
	config.read(config_file)

	return config["DEFAULT"]["LOGS_DIR"]


def generate_testrun_name(suffix):

	""" Creates a test run directory's name in the format
	test_<timestamp>_<suffix>.

	Args:
		suffix (str): human readable tag
	
	Returns:
		generated name.
	"""

	timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
	name = "test_{0}_{1}".format(timestamp, suffix)

	return name


def create_directories(location, suffix):

	""" Creates the run's directories.

	Args:
		suffix (str): appending dir name with a human readable tag.
	
	Returns:
		Name of all created directories
	"""

	overall_dir = bash_imitation.create_dir(location, generate_testrun_name(suffix))
	graph_dir = bash_imitation.create_dir(overall_dir, "graphs")
	raw_out_dir = bash_imitation.create_dir(overall_dir, "raw_out")
	csv_dir = bash_imitation.create_dir(overall_dir, "csv_files")


	return overall_dir, graph_dir, raw_out_dir, csv_dir


def reconstruct_directories(location, existing_directory):

	""" Reconstructs the structure of the existing directory and returns
	the inner directories.

	Args:
		location (str): location of existing directory
		existing_directory (str): name of existing directory

	Return:
		Name of all directories.
	"""

	overall_dir = os.path.join(location, existing_directory)
	graph_dir = os.path.join(overall_dir, "graphs")
	raw_out_dir = os.path.join(overall_dir, "raw_out")
	csv_dir = os.path.join(overall_dir, "csv_files")

	return overall_dir, graph_dir, raw_out_dir, csv_dir


def copy_and_create_metadata(location, config_file):

	""" Copies config file as params.ini, creates a metadata file of
	current git hash.

	Args:
		location (str): location in which all files are copied / created
		config_file (str): config file to be copied.
	
	Return: 
		None.
	"""

	# copy parameter file
	cmd = "cp {0} {1}".format(config_file, os.path.join(location, "params.ini"))
	lib.call(cmd, "could not copy params file.")

	# create git hash file
	with open(os.path.join(location, "git_commit_hash.txt"), "w") as f:
		git_commit_hash = bash_imitation.git_commit_hash()
		f.write("commit_hash: " + git_commit_hash)

		submodule = "vendor"
		git_submodule_hash = bash_imitation.git_submodule_commit_hash(submodule)
		f.write("\nsubmodule_commit_hash: " + git_submodule_hash)


def call_latency_throughput(location, baseline_file, lt_file, params_dir,
		params_file, csv_dir):

	""" Calls the latency throughput script, moves its generated logs, and 
	plots its csv files.

	Args:
		location (str): absolute path of location directory.
		baseline_file (str): original params config file, abs path
		lt_file (str): latency throughput params config, abs path
		params_dir(str): directory in which output param file lives
		params_file (str): file name of param file
		csv_dir(str): directory in which csv file will live
	
	Returns:
		None.
	"""

	cmd = "{0} {1} {2} {3} {4} {5} --driver_node localhost".format(
			LT_EXECUTABLE, baseline_file, lt_file, params_dir, params_file, csv_dir)
	lib.call(cmd, "lt_driver script failed")


def move_logs(baseline_file, raw_out_dir, new_dir_name):

	""" Moves logs generated by a run of the latency throughput script.

	Args:
		baseline_file (str): original params config file, abs path, used to
			construct source log directory.
		raw_out_dir (str): dir to which log dir will be moved, abs path.
		new_dir_name (str): name of new log directory.

	Returns:
		None.
	"""

	# move the generated logs
	src_logs = exp_lib.find_log_dir(FPATH, baseline_file)
	dest = os.path.join(raw_out_dir, new_dir_name)
	bash_imitation.move_logs(src_logs, dest)


def driver(baseline_file, csv_dir, csv_file, override_file):

	cmd = ("{0} --benchmark --driver_node localhost "
			"--ini_files {1} "
			"--csv_path {2} "
			"--csv_file {3} "
			"--override {4}").format(
				DRIVER_EXECUTABLE, baseline_file, csv_dir, csv_file, override_file)
	lib.call(cmd, "driver script failed")


def main():

	parser = argparse.ArgumentParser(description="coordinator script for pipeline")
	parser.add_argument("config", help=".ini file with config params, params.ini")
	parser.add_argument("lt_config", help=".ini file with latency throughput params")
	parser.add_argument("--stage", type=Stage, default=Stage.CREATE_NEW_DIRS, 
			choices=[str(member) for member in Stage],
			help="which stage to start running at. Useful for testing.")
	parser.add_argument("--run_single_stage", action="store_true",
			help="if set, do not continue after specified stage. Useful for testing.")
	parser.add_argument("--existing_directory",
			help="existing directory to use. Useful for testing.")

	args = parser.parse_args()
	args.config = os.path.join(FPATH, args.config) # replace with abs path
	args.lt_config = os.path.join(FPATH, args.lt_config)

	if args.stage is not Stage.CREATE_NEW_DIRS and not args.existing_directory:
		print("You must provide an existing test run directory with this stage.")
		parser.print_help()
		return -1

	# pipeline
	stage = args.stage
	overall_dir, graph_dir, raw_out_dir, csv_dir = None, None, None, None

	if stage == Stage.CREATE_NEW_DIRS:
		human_tag = extract_human_tag(args.config)
		overall_dir, graph_dir, raw_out_dir, csv_dir = create_directories(
				os.path.join(FPATH, ".."), human_tag)
		if args.run_single_stage:
			return 0
		stage = Stage.next(stage)
	else:
		overall_dir, graph_dir, raw_out_dir, csv_dir = reconstruct_directories(
				os.path.join(FPATH, ".."), args.existing_directory)

	if stage == Stage.METADATA:
		copy_and_create_metadata(overall_dir, args.config)
		if args.run_single_stage:
			return 0
		stage = Stage.next(stage)

	if stage == stage.LATENCY_THROUGHPUT:
		call_latency_throughput(overall_dir, args.config, args.lt_config,
				overall_dir, "override.ini", csv_dir)
		move_logs(args.config, raw_out_dir, "lt_logs")
		# plot_lt_graphs()
		if args.run_single_stage:
			return 0
		stage = Stage.next(stage)

	if stage == stage.DRIVER:
		driver(args.config, csv_dir, "driver.csv", os.path.join(overall_dir, "override.ini"))
		move_logs(args.config, raw_out_dir, "driver_logs")

	return 0


if __name__ == "__main__":
	sys.exit(main())
